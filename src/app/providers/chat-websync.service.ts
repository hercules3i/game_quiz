import { ElementRef, EventEmitter, Injectable } from '@angular/core';
import { ServiceService } from './service.service';
import { TranslateService } from '@ngx-translate/core';
import { Socket } from 'ngx-socket-io';
import { Subscription, lastValueFrom } from 'rxjs';
import { findLast } from 'lodash';
import { isAfter, parseISO } from 'date-fns';
import { Utf8EmojisToImagesPipe } from 'ng-utf8-emojis-to-images';
import { FileSupportService } from './file-support.service';
import { ConcurrencyTextToSpeech, markdownToHtml } from 'src/app/providers/cocurrency-text-to-speech/concurrency-text-to-speech';
import { OpenAiService } from 'src/app/providers/open-ai.service';
import { ScrollToHighlight } from 'src/app/page/audio-content/scroll-to-highlight';
import { PaymentService } from 'src/app/providers/payment.service';
import { NgxTruncateTextDirective } from 'ngx-truncate-text';
import { GoogleApiService } from './google-api.service';

declare var fm: any;

@Injectable({
  providedIn: 'root'
})
export class ChatWebsyncService {
  isTrans = false;
  isEnough;
  scrollToHighlight: ScrollToHighlight | undefined;
  isPageActive = true;
  highlightColors: string[] = [
    '#ff907f', '#00eda6', '#ede100',
    '#00d5d9', '#0228a6', '#7000d1',
  ];
  currentService = 'openai';
  currentHighlightColor = this.highlightColors[0];
  // superChannel = "/" + this.service.txtPinCode.toLowerCase() + "CHAT";
  messageReceivedEvent = new EventEmitter<any>();
  count = 0;
  messageSubscription: Subscription;
  listGroupChat: GroupChat[] = [
    // {
    //   GroupCode: 'TEST',
    //   GroupTitle: 'Test websync',
    //   Channel: 'Test websync',
    //   UserList: [],
    //   MessageContent: [],
    //   CreatedBy: 'admin',
    //   CreatedTime: '',
    // }
  ];
  currentGroupChat: GroupChat;
  /**
   * Channel name that used in websync
   * @date 1/3/2024 - 1:18:16 PM
   *
   * @type {string}
   */
  channel = '/' + 'CHAT_COMPONENT';
  channelGroupChat = 'GROUP_MANAGEMENT';
  /**
   * Clients generated by fm websync
   * @date 1/3/2024 - 1:18:39 PM
   *
   * @type {*}
   */
  clients: any;
  /**
   * List of messages
   * @date 1/3/2024 - 1:19:55 PM
   *
   * @type {Message[]}
   */
  messagges: Message[] = [];
  /**
   * Current message, used with streaming chat such chat GPT
   * @date 1/3/2024 - 1:20:22 PM
   *
   * @type {Message}
   */
  currentMessage!: Message;
  /**
   * Current page used for chat api pagination
   * @date 1/3/2024 - 1:20:44 PM
   *
   * @type {number}
   */
  page = 1;
  length = 10;
  manualKeyboardPadded = false;
  manualKeyboardPadding = 0;
  /**
   * Message element that are in footer component
   * @date 1/3/2024 - 1:21:06 PM
   *
   * @type {ElementRef<HTMLElement>}
   */
  messageEl!: ElementRef<HTMLElement>;
  isLoadGroupChat = false;
  initInfinity = true;
  titlePayment;
  isTranslating = false;
  listSpeechLanguage = ['vi-VN', 'en-US'];
  speechLanguage = this.listSpeechLanguage[0];
  listSupportedLanguages: Language[] = [
    { "name": "English", "code": "en-US", "img": "https://flagcdn.com/us.svg" },
    { "name": "Vietnamese", "code": "vi-VN", "img": "https://flagcdn.com/vn.svg" },
    { "name": "Korean", "code": "ko-KR", "img": "https://flagcdn.com/kr.svg" },
    { "name": "Chinese", "code": "zh-CN", "img": "https://flagcdn.com/cn.svg" },
    { "name": "Japanese", "code": "ja-JP", "img": "https://flagcdn.com/jp.svg" },
    { "name": "French", "code": "fr-FR", "img": "https://flagcdn.com/fr.svg" },
    { "name": "Dutch", "code": "nl-NL", "img": "https://flagcdn.com/nl.svg" },
    { "name": "Spanish", "code": "es-MX", "img": "https://flagcdn.com/mx.svg" },
    { "name": "Chinese (Taiwan)", "code": "zh-TW", "img": "https://flagcdn.com/tw.svg" },
    { "name": "Italian", "code": "it-IT", "img": "https://flagcdn.com/it.svg" },
    { "name": "English", "code": "en-ZA", "img": "https://flagcdn.com/us.svg" },
    { "name": "Catalan", "code": "ca-ES", "img": "https://flagcdn.com/es.svg" },
    { "name": "Spanish", "code": "es-CL", "img": "https://flagcdn.com/cl.svg" },
    { "name": "Romanian", "code": "ro-RO", "img": "https://flagcdn.com/ro.svg" },
    { "name": "French", "code": "fr-CH", "img": "https://flagcdn.com/fr.svg" },
    { "name": "English (Philippines)", "code": "en-PH", "img": "https://flagcdn.com/us.svg" },
    { "name": "English (Canada)", "code": "en-CA", "img": "https://flagcdn.com/us.svg" },
    { "name": "English (Singapore)", "code": "en-SG", "img": "https://flagcdn.com/us.svg" },
    { "name": "English (India)", "code": "en-IN", "img": "https://flagcdn.com/us.svg" },
    { "name": "English (New Zealand)", "code": "en-NZ", "img": "https://flagcdn.com/us.svg" },
    { "name": "Italian", "code": "it-CH", "img": "https://flagcdn.com/ch.svg" },
    { "name": "French (Canada)", "code": "fr-CA", "img": "https://flagcdn.com/fr.svg" },
    { "name": "Danish", "code": "da-DK", "img": "https://flagcdn.com/dk.svg" },
    { "name": "German", "code": "de-AT", "img": "https://flagcdn.com/at.svg" },
    { "name": "Portuguese", "code": "pt-BR", "img": "https://flagcdn.com/br.svg" },
    { "name": "Cantonese", "code": "yue-CN", "img": "https://flagcdn.com/cn.svg" },
    { "name": "Swedish", "code": "sv-SE", "img": "https://flagcdn.com/se.svg" },
    { "name": "Spanish", "code": "es-ES", "img": "https://flagcdn.com/es.svg" },
    { "name": "Arabic", "code": "ar-SA", "img": "https://flagcdn.com/sa.svg" },
    { "name": "Hungarian", "code": "hu-HU", "img": "https://flagcdn.com/hu.svg" },
    { "name": "French (Belgium)", "code": "fr-BE", "img": "https://flagcdn.com/fr.svg" },
    { "name": "English (United Kingdom)", "code": "en-GB", "img": "https://flagcdn.com/us.svg" },
    { "name": "Chinese (Hong Kong)", "code": "zh-HK", "img": "https://flagcdn.com/hk.svg" },
    { "name": "Finnish", "code": "fi-FI", "img": "https://flagcdn.com/fi.svg" },
    { "name": "Turkish", "code": "tr-TR", "img": "https://flagcdn.com/tr.svg" },
    { "name": "Norwegian", "code": "nb-NO", "img": "https://flagcdn.com/no.svg" },
    { "name": "English (Indonesia)", "code": "en-ID", "img": "https://flagcdn.com/us.svg" },
    { "name": "English (Saudi Arabia)", "code": "en-SA", "img": "https://flagcdn.com/us.svg" },
    { "name": "Polish", "code": "pl-PL", "img": "https://flagcdn.com/pl.svg" },
    { "name": "Indonesian", "code": "id-ID", "img": "https://flagcdn.com/id.svg" },
    { "name": "Malay", "code": "ms-MY", "img": "https://flagcdn.com/my.svg" },
    { "name": "Greek", "code": "el-GR", "img": "https://flagcdn.com/gr.svg" },
    { "name": "Czech", "code": "cs-CZ", "img": "https://flagcdn.com/cz.svg" },
    { "name": "Croatian", "code": "hr-HR", "img": "https://flagcdn.com/hr.svg" },
    { "name": "English (United Arab Emirates)", "code": "en-AE", "img": "https://flagcdn.com/us.svg" },
    { "name": "Hebrew", "code": "he-IL", "img": "https://flagcdn.com/il.svg" },
    { "name": "Russian", "code": "ru-RU", "img": "https://flagcdn.com/ru.svg" },
    { "name": "German", "code": "de-CH", "img": "https://flagcdn.com/ch.svg" },
    { "name": "English (Australia)", "code": "en-AU", "img": "https://flagcdn.com/us.svg" },
    { "name": "German", "code": "de-DE", "img": "https://flagcdn.com/de.svg" },
    { "name": "Dutch", "code": "nl-BE", "img": "https://flagcdn.com/be.svg" },
    { "name": "Thai", "code": "th-TH", "img": "https://flagcdn.com/th.svg" },
    { "name": "Portuguese", "code": "pt-PT", "img": "https://flagcdn.com/pt.svg" },
    { "name": "Slovak", "code": "sk-SK", "img": "https://flagcdn.com/sk.svg" },
    { "name": "English (Ireland)", "code": "en-IE", "img": "https://flagcdn.com/us.svg" },
    { "name": "Spanish", "code": "es-CO", "img": "https://flagcdn.com/co.svg" },
    { "name": "Ukrainian", "code": "uk-UA", "img": "https://flagcdn.com/ua.svg" },
    { "name": "Spanish", "code": "es-US", "img": "https://flagcdn.com/us.svg" },
    { "name": "Hindi", "code": "hi-IN", "img": "https://flagcdn.com/in.svg" },
    { "name": "Bengali (Bangladesh)", "code": "bn-BD", "img": "https://flagcdn.com/bd.svg" },
    { "name": "Bengali (Ấn Độ)", "code": "bn-IN", "img": "https://flagcdn.com/in.svg" },
    { "name": "Urdu", "code": "ur-PK", "img": "https://flagcdn.com/pk.svg" },
    { "name": "Tamil (Ấn Độ)", "code": "ta-IN", "img": "https://flagcdn.com/in.svg" },
    { "name": "Tamil (Sri Lanka)", "code": "ta-LK", "img": "https://flagcdn.com/lk.svg" },
    { "name": "Tamil (Singapore)", "code": "ta-SG", "img": "https://flagcdn.com/sg.svg" },
    { "name": "Tamil (Malaysia)", "code": "ta-MY", "img": "https://flagcdn.com/my.svg" },
    { "name": "Telugu", "code": "te-IN", "img": "https://flagcdn.com/in.svg" },
    { "name": "Marathi", "code": "mr-IN", "img": "https://flagcdn.com/in.svg" },
    { "name": "Punjabi (Ấn Độ)", "code": "pa-IN", "img": "https://flagcdn.com/in.svg" },
    { "name": "Punjabi (Pakistan)", "code": "pa-PK", "img": "https://flagcdn.com/pk.svg" },
    { "name": "Malayalam", "code": "ml-IN", "img": "https://flagcdn.com/in.svg" },
    { "name": "Kannada", "code": "kn-IN", "img": "https://flagcdn.com/in.svg" },
    { "name": "Gujarati", "code": "gu-IN", "img": "https://flagcdn.com/in.svg" },
    { "name": "Persian (Iran)", "code": "fa-IR", "img": "https://flagcdn.com/ir.svg" },
    { "name": "Persian (Afghanistan)", "code": "fa-AF", "img": "https://flagcdn.com/af.svg" },
    { "name": "Tajik", "code": "tg-TJ", "img": "https://flagcdn.com/tj.svg" },
    { "name": "Burmese", "code": "my-MM", "img": "https://flagcdn.com/mm.svg" },
    { "name": "Khmer", "code": "km-KH", "img": "https://flagcdn.com/kh.svg" },
    { "name": "Lao", "code": "lo-LA", "img": "https://flagcdn.com/la.svg" },
    { "name": "Swahili (Kenya)", "code": "sw-KE", "img": "https://flagcdn.com/ke.svg" },
    { "name": "Swahili (Tanzania)", "code": "sw-TZ", "img": "https://flagcdn.com/tz.svg" },
    { "name": "Swahili (Uganda)", "code": "sw-UG", "img": "https://flagcdn.com/ug.svg" },
    { "name": "Afrikaans", "code": "af-ZA", "img": "https://flagcdn.com/za.svg" },
    { "name": "Zulu", "code": "zu-ZA", "img": "https://flagcdn.com/za.svg" },
    { "name": "Hausa", "code": "ha-NG", "img": "https://flagcdn.com/ng.svg" },
    { "name": "Amharic", "code": "am-ET", "img": "https://flagcdn.com/et.svg" },
    { "name": "Pashto (Afghanistan)", "code": "ps-AF", "img": "https://flagcdn.com/af.svg" },
    { "name": "Pashto (Pakistan)", "code": "ps-PK", "img": "https://flagcdn.com/pk.svg" },
    { "name": "Mongolian", "code": "mn-MN", "img": "https://flagcdn.com/mn.svg" },
    { "name": "Serbian", "code": "sr-RS", "img": "https://flagcdn.com/rs.svg" },
    { "name": "Bosnian", "code": "bs-BA", "img": "https://flagcdn.com/ba.svg" },
    { "name": "Macedonian", "code": "mk-MK", "img": "https://flagcdn.com/mk.svg" },
    { "name": "Slovenian", "code": "sl-SI", "img": "https://flagcdn.com/si.svg" },
    { "name": "Estonian", "code": "et-EE", "img": "https://flagcdn.com/ee.svg" },
    { "name": "Latvian", "code": "lv-LV", "img": "https://flagcdn.com/lv.svg" },
    { "name": "Lithuanian", "code": "lt-LT", "img": "https://flagcdn.com/lt.svg" },
    { "name": "Welsh", "code": "cy-GB", "img": "https://flagcdn.com/gb.svg" },
    { "name": "Basque", "code": "eu-ES", "img": "https://flagcdn.com/es.svg" },
    { "name": "Galician", "code": "gl-ES", "img": "https://flagcdn.com/es.svg" },
    { "name": "Icelandic", "code": "is-IS", "img": "https://flagcdn.com/is.svg" },
    { "name": "Maltese", "code": "mt-MT", "img": "https://flagcdn.com/mt.svg" }
  ];
  constructor(
    public service: ServiceService,
    public translate: TranslateService,
    private socket: Socket,
    private pipe: Utf8EmojisToImagesPipe,
    private fileSupport: FileSupportService,
    private openAi: OpenAiService,
    private googleApi: GoogleApiService,
    public payment: PaymentService,
  ) {
  }
  async initWebsync() {
    fm.websync.client.enableMultiple = true;
    if (!this.isConnected()) {
      this.connect(this.service.websyncServerAddress);
    }
    // this.getListGroupChat();
    this.listSpeechLanguage = this.getToggleLanguages();
    await this.updateSpeechLanguage();
    this.service.set('currentLanguage', this.listSpeechLanguage)
  }
  initChat(data: GroupChat) {
    this.currentGroupChat = this.listGroupChat.find(x => x.GroupCode === data.GroupCode);
    if (this.currentGroupChat == null) {
      this.currentGroupChat = data;
      this.listGroupChat.push(this.currentGroupChat);
    }
    this.page = 1;
    this.messagges = this.getMessageWithPage();
    // this.chatService.channelDb = this.channel;
    this.channel = `/${this.currentGroupChat.Channel}`;
    const master = this.getRandomElement(this.currentGroupChat.UserList.filter(x => x.Status === 'online'
      && x.UserName !== this.service.userName));
    if (master) {
      this.sendCommandInOut('request_channel_info', null, master.UserName);
    }
    // this.chatService.connect();
    this.subscribe();
    // this.chatService.getLogMessagePage();
  }
  getRandomElement<T>(arr: T[]): T | undefined {
    if (arr.length === 0) {
      return undefined; // Return undefined if the array is empty
    }

    const randomIndex = Math.floor(Math.random() * arr.length);
    return arr[randomIndex];
  }
  loadMoreMessage() {
    this.page++;
    const messages = this.getMessageWithPage();
    this.messagges = messages.concat(this.messagges);
  }
  getMessageWithPage() {
    const startIndex = (this.page - 1) * this.length;
    const messages = this.currentGroupChat.MessageContent.filter(x => x.Type === 'message' || x.Type === 'file').map(x => ({
      content: x.Message,
      url: x.Url,
      mimeType: x.MimeType,
      type: x.Type as 'file' | 'message',
      me: this.service.userName === x.UserName,
      name: x.GivenName,
      timeChat: x.TimeChat,
      avatar: x.Picture
    } as Message));
    messages.forEach(async (mess, index) => {
      const transText = await this.service.get(`chat__${mess.timeChat}`)
      if (transText) {
        messages[index].translatedContent = transText;
      }
    })
    const subList = this.getSublist(messages, startIndex, this.length);
    return subList.reverse();
  }
  getSublist<T>(list: T[], startIndex: number, length: number): T[] {
    // Ensure startIndex is within the bounds of the list
    if (startIndex < 0 /* || startIndex >= list.length */) {
      throw new Error('Invalid startIndex');
    }

    // Ensure length is a positive integer
    if (length <= 0 || !Number.isInteger(length)) {
      throw new Error('Invalid length');
    }

    // Calculate the end index of the sublist
    const endIndex = startIndex + length;

    // Return the sublist using slice
    return list.slice(startIndex, endIndex);
  }
  async getListGroupChat() {
    let listGroupChat: GroupChat[] = [];
    try {
      listGroupChat = await this.service.get('LIST_GROUP_CHAT');
    } catch (error) {
      console.log(error);
    }
    if (listGroupChat && listGroupChat.length && listGroupChat.length !== 0) {
      this.listGroupChat = listGroupChat;
    }
    // else {
    //   await this.getListGroupChatApi();
    // }
    await this.getListGroupChatApi();
    this.isLoadGroupChat = true;
  }
  async getListGroupChatApi(groupCode = '', isAll = false) {
    let result: GroupChatApi[];
    let userName = this.service.userName;
    if (isAll) {
      userName = '';
    }
    try {
      result = await lastValueFrom<GroupChatApi[]>(this.service.getApi(this.service.getHost() +
        `MobileChat/GetListGroupChat?userFilter=` + userName));
    } catch (error) {
      console.log(error);
      this.service.messageSuccess(this.translate.instant('NOTI.NOTI_CONNECTING'));
    }
    if (result) {
      if (groupCode) {
        this.updateListGroupChat(groupCode, result);
      }
      else {
        // delete old group chat that not exist anymore or being quit
        this.listGroupChat = this.listGroupChat.filter(x => result.some(y => y.GroupCode === x.GroupCode));
        for (const group of result) {
          this.updateListGroupChat(group.GroupCode, result);
        }
      }
      try {
        await this.service.set('LIST_GROUP_CHAT', this.listGroupChat);
      } catch (error) {
        console.log(error);
      }
    }
  }
  async getItemGroupChatApi(groupCode: string) {
    let result: GroupChatApi;
    try {
      result = await lastValueFrom<GroupChatApi>(this.service.getApi(this.service.getHost() +
        `MobileChat/GetItemGroupChatWithCode?code=` + groupCode));
    } catch (error) {
      console.log(error);
      this.service.messageSuccess(this.translate.instant('NOTI.NOTI_CONNECTING'));
    }
    if (result) {
      let groupChat = this.listGroupChat.find(x => x.GroupCode === groupCode);
      if (groupChat != null) {
        return groupChat;
      }
      else {
        this.updateListGroupChat(result.GroupCode, [result]);
        groupChat = this.listGroupChat.find(x => x.GroupCode === groupCode);
        return groupChat;
      }
      // return groupChat;
    }
    return null;
  }
  async addGroupChat(group: GroupChat) {
    let result: any;
    try {
      const body = {
        GroupCode: group.GroupCode,
        GroupChanel: group.Channel,
        GroupName: group.GroupTitle,
        ListUser: group.UserList,
        UserName: this.service.userName
      };
      result = await lastValueFrom(this.service.postApi(this.service.getHost() + 'MobileChat/AddGroupChat', body));
    } catch (error) {
      console.log(error);
      this.service.messageSuccess(this.translate.instant('NOTI.NOTI_CONNECTING'));
    }
    if (result) {
      if (result.Error === false) {
        // this.service.messageSuccess(this.translate.instant('Insert.Insert_SUCCESS'));
        this.getListGroupChatApi(group.GroupCode);
      }
      else {
        this.service.messageError(this.translate.instant('Insert.Insert_ERROR'));
      }
    }
  }
  async updateGroupChat(group: GroupChat) {
    let result: any;
    try {
      const body = {
        Id: group.Id,
        GroupName: group.GroupTitle,
        ListUser: group.UserList,
        UserName: this.service.userName
      };
      result = await lastValueFrom(this.service.putApiJson<any>(this.service.getHost() + 'MobileChat/UpdateGroupChat', body));
    } catch (error) {
      console.log(error);
      this.service.messageSuccess(this.translate.instant('NOTI.NOTI_CONNECTING'));
    }
    if (result) {
      if (result.Error === false) {
        this.getListGroupChatApi();
        return true;
      }
      else {
        this.service.messageError(this.translate.instant('NOTI.NOTI_UPDATE_FAIL'));
      }
    }
    return false;
  }
  async updateGroupNameChat(group: any) {
    let result: any;
    try {
      const body = {
        Id: group.Id,
        GroupName: group.GroupTitle,
        UserName: this.service.userName
      };
      result = await lastValueFrom(this.service.putApi(this.service.getHost() + 'MobileChat/UpdateGroupNameChat', body));
    } catch (error) {
      console.log(error);
      this.service.messageError(this.translate.instant("NOTI.NOTI_CONNECT_SERVER_ERROR"));
    }
    if (result) {
      if (result.Error === false) {
        this.getListGroupChatApi();
        return true;
      }
      else {
        this.service.messageError(this.translate.instant('NOTI.NOTI_UPDATE_FAIL'));
      }
    }
    return false;
  }
  /**
   * Connect to websync server at url
   * @date 2/1/2024 - 9:49:51 AM
   *
   * @param {string} [url='https://websync.3i.com.vn/websync.ashx']
   */
  connect(url = 'https://websync.3i.com.vn/websync.ashx') {
    this.clients = new fm.websync.client(url);
    this.clients.connect({
      onSuccess: (args: any) => {
        console.log('Connect success ');
      },
      onFailure: (args: any) => {
        console.log('Connect error websync');
      }
    });
  }
  /**
   * Check if websync client is connected to server
   * @date 2/1/2024 - 11:04:46 AM
   *
   * @returns {boolean}
   */
  isConnected(): boolean {
    if (this.clients) {
      return this.clients._isConnected;
    }
    return false;
  }
  /**
   * Disconnect from websync server
   * @date 1/3/2024 - 1:22:25 PM
   */
  disconnect() {
    this.clients.disconnect();
  }
  /**
   * Subscribe to websync server for incoming message
   * @date 1/3/2024 - 1:21:38 PM
   */
  subscribe() {
    const that = this;
    this.clients.subscribe({
      channel: that.channel,
      onSuccess(args: any) {
        console.log('subscribe success');
      },
      onFailure(args: any) {
        console.log('subscribe failed');
      },
      onReceive(args: any) {
        const message = args.getData();
        // console.log('sds ' + JSON.stringify(message));
        if (message.messageType === 'message') {
          that.sendMess(message.userName, message.name, message.text, message.avatar, args.getWasSentByMe(), message.time);
        }
        else if (message.messageType === 'file') {
          that.sendFilePrivate(message.userName, message.name, message.fileName, message.fileUrl, message.mimeType, message.avatar, args.getWasSentByMe(), message.time);
        }
        else {
          that.sendCommandPrivate(message.userName, message.name, message.command, message.avatar, args.getWasSentByMe(), message.time, message.syncData, message.target)
        }
        // that.removeContentChat();
      }
    });
  }
  unsubscribe() {
    const that = this;
    this.clients.subscribe({
      channel: that.channel,
      onSuccess(args: any) {
        console.log('unsubscribe success');
      },
      onFailure(args: any) {
        console.log('unsubscribe failed');
      }
    });
  }
  /**
   * Subscribe to websync server for incoming group management command
   * @date 1/3/2024 - 1:21:38 PM
   */
  subscribeToGroupChatManagement() {
    const that = this;
    this.clients.subscribe({
      channel: that.channelGroupChat,
      onSuccess(args: any) {
      },
      onFailure(args: any) {
      },
      onReceive(args: any) {
        const message = args.getData();
        // console.log('sds ' + JSON.stringify(message));
        // that.sendMess(message.userName, message.name, message.text, message.avatar, args.getWasSentByMe(), message.time);
        // that.removeContentChat();
      }
    });
  }
  /**
   * Send a command to entire participants of the group management channel
   * @date 2/1/2024 - 10:12:36 AM
   *
   * @param {string} command
   * @param {*} data
   */
  sendCommand(command: string, data: any) {
    this.clients.publish({
      channel: this.channelGroupChat,
      data: {
        type: 999,
        from: 'driver',
        locationMessage: {
          driverId: this.service.id,
        },
        userName: this.service.userName,
        name: this.service.displayName,
        command,
        data
      },
      onSuccess(args: any) {
        console.log('publish success');
      },
      onFailure(args: any) {
        console.log('publish failed');
      },
      onReceive(args: any) {

      }
    });
  }
  /**
   * Send a message to entire participants of the current websync channel
   * @date 1/3/2024 - 1:23:30 PM
   *
   * @param {*} messageChat
   */
  send(messageChat: string) {
    let avatar = this.service.img;
    const convertedHtml = this.pipe.emojisToImages(messageChat, 'apple');
    try {
      var url = new URL(avatar);
    } catch (error) {
      avatar = this.service.getHost() + this.service.img;
    }
    this.clients.publish({
      channel: this.channel,
      data: {
        type: 999,
        from: 'driver',
        locationMessage: {
          driverId: this.service.id,
        },
        userName: this.service.userName,
        name: this.service.displayName,
        text: convertedHtml,
        avatar,
        messageType: 'message',
        time: (new Date()).toISOString()
      },
      onSuccess(args: any) {

      },
      onFailure(args: any) {

      },
      onReceive(args: any) {

      }
    });
    // this.insertLogMessage(this.channelDb, messageChat, this.service.userName, this.service.getHost() + this.service.img, this.service.displayName, this.service.userName, moment(new Date()).add().format('HH:mm'));
  }
  async sendFile() {
    let fileUrl = await this.fileSupport.uploadFileWithType('*/*');
    let avatar = this.service.img;
    try {
      var url = new URL(avatar);
    } catch (error) {
      avatar = this.service.getHost() + this.service.img;
    }
    this.clients.publish({
      channel: this.channel,
      data: {
        type: 999,
        from: 'driver',
        locationMessage: {
          driverId: this.service.id,
        },
        userName: this.service.userName,
        name: this.service.displayName,
        // text: convertedHtml,
        fileUrl,
        fileName: this.fileSupport.fileNameUpload,
        mimeType: this.fileSupport.mimeType,
        avatar,
        messageType: 'file',
        time: (new Date()).toISOString()
      },
      onSuccess(args: any) {

      },
      onFailure(args: any) {

      },
      onReceive(args: any) {

      }
    });
  }
  async viewFile(mess: Message) {
    console.log(mess);
    const url = this.service.getHost() + mess.url;
    await this.fileSupport.openFile(mess.content, url, mess.mimeType);
  }
  sendCommandInOut(command: string, syncData = null, target = '') {
    let avatar = this.service.img;
    try {
      var url = new URL(avatar);
    } catch (error) {
      avatar = this.service.getHost() + this.service.img;
    }
    this.clients.publish({
      channel: this.channel,
      data: {
        type: 999,
        from: 'driver',
        locationMessage: {
          driverId: this.service.id,
        },
        userName: this.service.userName,
        name: this.service.displayName,
        command,
        avatar,
        messageType: 'command',
        time: (new Date()).toISOString(),
        syncData,
        target
      },
      onSuccess(args: any) {

      },
      onFailure(args: any) {

      },
      onReceive(args: any) {

      }
    });
  }
  removeUser(userName: string) {
    this.sendCommandInOut('quit', null, userName);
  }
  /**
   * Get current height of message element inside footer component
   * @date 1/3/2024 - 1:24:54 PM
   *
   * @returns {string}
   */
  getMessageHeight() {
    return (this.messageEl?.nativeElement.offsetHeight ?? 0 + 1) + 'px';
  }
  wait01sec() {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve('Ok');
      }, 100);
    });
  }
  private async sendCommandPrivate(userName: string, name: string, command: string, avatar: string, me: any, time: string, data: any = null, target = '') {

    this.currentGroupChat.MessageContent.unshift({
      UserName: userName,
      GivenName: name,
      TimeChat: time,
      Command: command,
      Type: 'command',
      Picture: avatar,
    });
    switch (command) {
      case 'subscribe':
        this.updateUserStatus(userName, 'online');
        break;
      case 'ubsubscribe':
        this.updateUserStatus(userName, 'offline');
        break;
      case 'join':
        break;
      case 'quit':
        this.removeUserPrivate(userName, target);
        break;
      case 'send_channel_info':
        this.receiveChannelInfo(target, data)
        break;
      case 'request_channel_info':
        this.checkSendChannelInfo(userName, target);
        break;
      default:
        break;
    }
    try {
      this.service.set('LIST_GROUP_CHAT', this.listGroupChat);
    } catch (error) {
      console.log(error);
    }
  }
  private removeUserPrivate(userName: string, target: string) {
    const index = this.currentGroupChat.UserList.findIndex(x => x.UserName === target);
    if (index !== -1) {
      this.currentGroupChat.UserList.splice(index, 1);
    }
    if (userName === this.service.userName) {
      this.updateGroupChat(this.currentGroupChat);
    }
  }
  private updateUserStatus(userName: string, status: UserChatStatus) {
    let user = this.currentGroupChat.UserList.find(x => x.UserName === userName);
    if (user == null) {
      user = {
        UserId: this.service.id,
        UserName: this.service.userName,
        GivenName: this.service.displayName,
        Picture: this.service.img,
        Status: status
      };
      this.currentGroupChat.UserList.push(user);
    } else {
      user.Status = status;
    }
    if (userName === this.service.userName) {
      this.updateGroupChat(this.currentGroupChat);
    }
  }
  private async receiveChannelInfo(target: string, syncData: UserMessage[]) {
    if (this.service.userName === target) {
      this.currentGroupChat.MessageContent = syncData;
      this.page = 1;
      this.messagges = this.getMessageWithPage();
      this.initInfinity = false;
      await this.wait01sec();
      this.initInfinity = true;
    }
  }
  private async checkSendChannelInfo(userName: string, target: string) {
    if (this.service.userName === target && this.service.userName !== userName) {
      const messageNeedSync = this.checkParticipantSync(userName);
      if (messageNeedSync.length > 0) {
        console.log('sync target', userName);
        const messageWillSync = this.currentGroupChat.MessageContent;
        this.sendCommandInOut('send_channel_info', messageWillSync, userName);
      }
    }
  }
  private checkParticipantSync(userName: string) {
    const lastUnsubscribe = this.currentGroupChat.MessageContent
      .find(x => x.Type === 'command' && x.Command === 'unsubscribe' && x.UserName === userName);
    if (lastUnsubscribe == null) {
      return this.currentGroupChat.MessageContent;
    }
    const lastUnsubscribeTime = parseISO(lastUnsubscribe.TimeChat);
    return this.currentGroupChat.MessageContent.filter(x =>
      isAfter(parseISO(x.TimeChat), lastUnsubscribeTime));
    // const checkIfMessageNeedSync = this.currentGroupChat.MessageContent.some(x => )
  }
  private updateListGroupChat(groupCode: string, result: GroupChatApi[]) {
    const updateGroupChat = result.find(x => x.GroupCode === groupCode);
    const oldGroupChat = this.listGroupChat.find(x => x.GroupCode === groupCode);
    if (oldGroupChat) {
      oldGroupChat.GroupTitle = updateGroupChat.GroupName;
      oldGroupChat.UserList = updateGroupChat.ListUser;
    }
    else {
      const newGroupChat = [updateGroupChat].map(x => ({
        Id: x.Id,
        GroupCode: x.GroupCode,
        GroupTitle: x.GroupName,
        Channel: x.GroupChanel,
        UserList: x.ListUser,
        MessageContent: [],
        CreatedBy: x.CreatedBy,
        CreatedTime: x.CreatedTime
      }))[0];
      this.listGroupChat.push(newGroupChat);
    }
  }
  private async sendMess(userName: string, name: string, text: string, avatar: string, me: any, time: string) {
    const modifiedString = (text as string)?.replace(/^\n+/, '') ?? '';
    let textTrim = modifiedString.trimStart() ?? '';
    let transText;
    if (textTrim.includes('___')) {
      const splitText = textTrim.split('___');
      textTrim = splitText[0];
      transText = splitText[1];
    }
    if (userName === this.service.userName) {
      const currentIndex = this.messagges.length;
      this.currentMessage = {
        content: textTrim,
        me: true,
        name,
        type: 'message',
        timeChat: time,
        translatedContent: transText || null,
        concurrencyTTS: new ConcurrencyTextToSpeech(
          this.openAi,
          'fable',
          1,
          this,
          () => {
            const isPlaying = this.messagges.findIndex((el, index) => el.isPlay == true && index != currentIndex)
            return isPlaying != -1
          },
          this.googleApi,
          this.currentService
        ),
      };
      this.service.set(`chat__${time}`, transText)
      const concurrencyTTS = this.currentMessage.concurrencyTTS;
      if (concurrencyTTS && transText) {
        concurrencyTTS.pushContent(transText, true);
      }
      this.messagges.push(this.currentMessage);
      this.messagges[currentIndex].concurrencyTTS.message = this.messagges[currentIndex];
    }
    else {
      let transText
      const currentIndex = this.messagges.length;
      if (this.isTrans && textTrim && textTrim != '') {
        const lang = await this.service.get('currentLanguage')
        transText = await this.translatedContent(textTrim, lang[0], lang[1])
      }
      this.currentMessage = {
        content: textTrim,
        me: false,
        name,
        type: 'message',
        timeChat: time,
        avatar,
        translatedContent: transText || null,
        concurrencyTTS: new ConcurrencyTextToSpeech(
          this.openAi,
          'fable',
          1,
          this,
          () => {
            const isPlaying = this.messagges.findIndex((el, index) => el.isPlay == true && index != currentIndex)
            return isPlaying != -1
          },
          this.googleApi,
          this.currentService
        ),
      };
      this.service.set(`chat__${time}`, transText)
      const concurrencyTTS = this.currentMessage.concurrencyTTS;
      if (concurrencyTTS && transText) {
        concurrencyTTS.pushContent(transText, true);
      }
      this.messagges.push(this.currentMessage);
      this.messagges[currentIndex].concurrencyTTS.message = this.messagges[currentIndex];
    }
    this.currentGroupChat.MessageContent.unshift({
      UserName: userName,
      GivenName: name,
      TimeChat: time,
      Message: textTrim,
      Type: 'message',
      Picture: avatar
    });
    try {
      this.service.set('LIST_GROUP_CHAT', this.listGroupChat);
    } catch (error) {
      console.log(error);
    }
    // this.content.scrollToBottom(0);
  }
  private sendFilePrivate(userName: string, name: string, fileName: string, fileUrl: string, mimeType: string, avatar: string, me: any, time: string) {
    // const modifiedString = (text as string)?.replace(/^\n+/, '') ?? '';
    // const textTrim = modifiedString.trimStart() ?? '';
    if (userName === this.service.userName) {
      this.currentMessage = {
        content: fileName,
        url: fileUrl,
        mimeType,
        me: true,
        name,
        type: 'file',
        timeChat: time
      };
      this.messagges.push(this.currentMessage);
    }
    else {
      this.currentMessage = {
        content: fileName,
        url: fileUrl,
        mimeType,
        me: false,
        name,
        type: 'file',
        timeChat: time,
        avatar
      };
      this.messagges.push(this.currentMessage);
    }
    this.currentGroupChat.MessageContent.unshift({
      UserName: userName,
      GivenName: name,
      TimeChat: time,
      Message: fileName,
      Url: fileUrl,
      MimeType: mimeType,
      Type: 'file',
      Picture: avatar
    });
    try {
      this.service.set('LIST_GROUP_CHAT', this.listGroupChat);
    } catch (error) {
      console.log(error);
    }
    // this.content.scrollToBottom(0);
  }

  toggleSpeechMessage(event: Event, messageId: number) {
    event.stopPropagation();
    this.stopAllAudio(messageId);

    const message = this.messagges[messageId];
    if (!message) return;

    if (!message.isPlay) {
      const tts = message.concurrencyTTS;
      if (!tts) return console.error('concurrencyTTS is undefined');
      tts.startPlayAudio();
      message.isPlay = true;
    } else {
      message.isPlay = false;
    }
  }

  stopAllAudio(excludeMessageIndex?: number) {
    this.messagges.forEach((msg, index) => {
      if (index == excludeMessageIndex) return;

      if (msg.concurrencyTTS) {
        msg.concurrencyTTS.stopPlayAudio();
      }
    });

    Howler.stop();
  }

  async checkCredit() {
    this.isEnough = await this.payment.checkAndPurchaseCredit();
    if (!this.isEnough) {
      this.service.messageError(this.translate.instant('STUDY_WITH_AI.NOT_ENOUGH_CREDIT'));
      // this.backPage();
      return false;
    } else {
      this.titlePayment = await lastValueFrom(this.translate
        .get('STUDY_WITH_AI.TS_TITLE_PAYMENT', {
          price: this.payment.aiChargeTracking.Credit.toFixed(3),
        }));
      return true;
    }
  }

  async setCredit() {
    const numberPaymentBefore = parseFloat(this.titlePayment.split(":")[1].trim());

    this.titlePayment = await lastValueFrom(this.translate
      .get('STUDY_WITH_AI.TS_TITLE_PAYMENT', {
        price: this.payment.aiChargeTracking.Credit.toFixed(3),
      }));

    const numberPayment = parseFloat(this.titlePayment.split(":")[1].trim());
    this.currentMessage.creditChange = parseFloat((numberPayment - numberPaymentBefore).toFixed(3)) * 1000
    this.currentMessage.creditTotal = numberPayment * 1000;
  }

  async translatedContent(message: string, lang1: string, lang2: string) {
    this.isTranslating = true;
    if (this.currentService === 'openai') {
      const text = `Bạn là phiên dịch viên giữa ${lang1} và ${lang2}, hãy xác định ngôn ngữ nhận được và dịch sang ngôn ngữ còn lại và không nói gì thêm. `
        // + `Nếu không phải một trong hai ngôn ngữ, dịch sang ${lang1} .`
        + `Dịch: ${message}`
      const content = await this.openAi.getDataFromOpenAI(text, 'user');
      this.isTranslating = false;
      return content;
    }
    if (this.currentService === 'google') {
      const lang = await this.googleApi.detect(message);
      if (lang1.includes(lang)) {
        console.log('lang is in lang1, translate to lang2');
        const content = await this.googleApi.translate(message, lang2);
        this.isTranslating = false;
        return content;
      }
      else {
        console.log('lang is in lang2, translate to lang1');
        const content = await this.googleApi.translate(message, lang1);
        this.isTranslating = false;
        return content;
      }
    }
  }

  async updateSpeechLanguage() {
    this.speechLanguage = this.listSpeechLanguage[0];
    console.log('[updateSpeechLanguage] init', this.speechLanguage);
  }

  getToggleLanguages(): string[] {
    const appLang = this.service.ListLanguage.find(item => item.Code == this.service.language);
    const systemLang = this.translate.getBrowserCultureLang();

    if (appLang && appLang.lang != systemLang) return [appLang.lang, systemLang];
    if (!systemLang.startsWith('en')) return [systemLang, 'en-US'];
    return ['en-US', 'vi-VN'];
  }

}

export interface MetaObject {
  pinCode: string;
  tokenDevice: string;
}
export interface GroupChat {
  Id?: number;
  GroupCode: string;
  GroupTitle: string;
  Channel: string;
  UserList: UserChat[];
  MessageContent: UserMessage[];
  Type?: string;
  CreatedBy: string;
  CreatedTime: string;
}
export interface GroupChatApi {
  Id: number
  GroupCode: string
  GroupChanel: string
  GroupName: string
  JsonData: string
  ListUser: UserChat[]
  ObjectRelative: any
  CreatedBy: string
  CreatedTime: string
  IsDeleted: boolean
}
export interface UserChat {
  UserId: string;
  UserName: string;
  GivenName: string;
  Picture: string;
  Status: UserChatStatus;
}
export type UserChatStatus = 'online' | 'offline';
export interface UserMessage {
  UserName: string;
  GivenName: string;
  TimeChat: string;
  Message?: string;
  Url?: string;
  MimeType?: string;
  Command?: string;
  Data?: string;
  Type: UserMessageType;
  Picture: string;
  translatedContent?: string;
}
export type UserMessageType = 'message' | 'command' | 'file';

/**
 * Message interface for message object
 * @date 1/3/2024 - 1:32:14 PM
 *
 * @export
 * @interface Message
 * @typedef {Message}
 */
export interface Message {
  id?: number;
  /**
   * Content of the message
   * @date 1/3/2024 - 1:32:32 PM
   *
   * @type {string}
   */
  content?: string;
  /**
   * Boolean that tell this message is belong to current user or not
   * @date 1/3/2024 - 1:32:44 PM
   *
   * @type {boolean}
   */
  me: boolean;
  /**
   * Time that this message was sent
   * @date 1/3/2024 - 1:33:15 PM
   *
   * @type {string}
   */
  timeChat: string;
  /**
   * The display name of the user sent the message
   * @date 1/3/2024 - 1:33:32 PM
   *
   * @type {string}
   */
  name: string;
  type: MessageType;
  url?: string;
  mimeType?: string;
  /**
   * The avatar of the user sent the message
   * @date 1/3/2024 - 1:33:50 PM
   *
   * @type {?string}
   */
  avatar?: string;
  translatedContent?: string;
  isPlay?: boolean;
  concurrencyTTS?: ConcurrencyTextToSpeech;
  creditTotal?: number;
  creditChange?: number;
  voice?: string; // Add voice property to store the voice used for this message
}
export interface Language {
  /// e.g. English
  name: string

  /// e.g. en-US
  code: string

  img: string
}
export type MessageType = 'message' | 'file';
